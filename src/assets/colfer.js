// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file types.colf for package colfer.


var colfer = new function() {
	const EOF = 'colfer: EOF';

	// The upper limit for serial byte sizes.
	var colferSizeMax = 16 * 1024 * 1024;
	// The upper limit for the number of elements in a list.
	var colferListMax = 64 * 1024;

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Justification = function(init) {

		this.Key = '';

		this.Value = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.Justification.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.Key) {
			buf[i++] = 0;
			var utf8 = encodeUTF8(this.Key);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.Value) {
			buf[i++] = 1;
			view.setFloat64(i, this.Value);
			i += 8;
		} else if (Number.isNaN(this.Value)) {
			buf.set([1, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.Justification serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Justification.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Justification.Key size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Justification.Key size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.Key = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Value = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.Justification serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Transaction = function(init) {

		this.ID = new Uint8Array(0);

		this.Cleared = false;

		this.Commission = 0;

		this.CompositeFIGI = '';

		this.Date = null;
		this.Date_ns = 0;

		this.Justification = [];

		this.Kind = '';

		this.Memo = '';

		this.PricePerShare = 0;

		this.Shares = 0;

		this.Source = '';

		this.SourceID = new Uint8Array(0);

		this.Tags = [];

		this.TaxDisposition = '';

		this.Ticker = '';

		this.TotalValue = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property Justification will be replaced with a new colfer.Justification.
	// All null entries in property Tags will be replaced with an empty String.
	this.Transaction.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.ID && this.ID.length) {
			buf[i++] = 0;
			var b = this.ID;
			i = encodeVarint(buf, i, b.length);
			buf.set(b, i);
			i += b.length;
		}

		if (this.Cleared)
			buf[i++] = 1;

		if (this.Commission) {
			buf[i++] = 2;
			view.setFloat64(i, this.Commission);
			i += 8;
		} else if (Number.isNaN(this.Commission)) {
			buf.set([2, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.CompositeFIGI) {
			buf[i++] = 3;
			var utf8 = encodeUTF8(this.CompositeFIGI);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if ((this.Date && this.Date.getTime()) || this.Date_ns) {
			var ms = this.Date ? this.Date.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.Date_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/Transaction field Date_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 4 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 4;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if (this.Justification && this.Justification.length) {
			var a = this.Justification;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.Transaction.Justification length exceeds colferListMax');
			buf[i++] = 5;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.Justification();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.Kind) {
			buf[i++] = 6;
			var utf8 = encodeUTF8(this.Kind);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.Memo) {
			buf[i++] = 7;
			var utf8 = encodeUTF8(this.Memo);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.PricePerShare) {
			buf[i++] = 8;
			view.setFloat64(i, this.PricePerShare);
			i += 8;
		} else if (Number.isNaN(this.PricePerShare)) {
			buf.set([8, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.Shares) {
			buf[i++] = 9;
			view.setFloat64(i, this.Shares);
			i += 8;
		} else if (Number.isNaN(this.Shares)) {
			buf.set([9, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.Source) {
			buf[i++] = 10;
			var utf8 = encodeUTF8(this.Source);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.SourceID && this.SourceID.length) {
			buf[i++] = 11;
			var b = this.SourceID;
			i = encodeVarint(buf, i, b.length);
			buf.set(b, i);
			i += b.length;
		}

		if (this.Tags && this.Tags.length) {
			var a = this.Tags;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.Transaction.Tags length exceeds colferListMax');
			buf[i++] = 12;
			i = encodeVarint(buf, i, a.length);

			a.forEach(function(s, si) {
				if (s == null) {
					s = "";
					a[si] = s;
				}
				var utf8 = encodeUTF8(s);
				i = encodeVarint(buf, i, utf8.length);
				buf.set(utf8, i);
				i += utf8.length;
			});
		}

		if (this.TaxDisposition) {
			buf[i++] = 13;
			var utf8 = encodeUTF8(this.TaxDisposition);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.Ticker) {
			buf[i++] = 14;
			var utf8 = encodeUTF8(this.Ticker);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.TotalValue) {
			buf[i++] = 15;
			view.setFloat64(i, this.TotalValue);
			i += 8;
		} else if (Number.isNaN(this.TotalValue)) {
			buf.set([15, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.Transaction serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Transaction.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Transaction.ID size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Transaction.ID size ' + size + ' exceeds ' + colferSizeMax + ' bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.ID = data.slice(start, i);
			readHeader();
		}

		if (header == 1) {
			this.Cleared = true;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Commission = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 3) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Transaction.CompositeFIGI size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Transaction.CompositeFIGI size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.CompositeFIGI = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 4) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.Date = new Date(ms);
			this.Date_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (4 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field Date exceeds ECMA Date range');
			this.Date = new Date(ms);
			this.Date_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 5) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.Transaction.Justification length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.Transaction.Justification length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.Justification();
				i += o.unmarshal(data.subarray(i));
				this.Justification[n] = o;
			}
			readHeader();
		}

		if (header == 6) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Transaction.Kind size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Transaction.Kind size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.Kind = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 7) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Transaction.Memo size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Transaction.Memo size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.Memo = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 8) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.PricePerShare = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 9) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Shares = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 10) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Transaction.Source size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Transaction.Source size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.Source = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 11) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Transaction.SourceID size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Transaction.SourceID size ' + size + ' exceeds ' + colferSizeMax + ' bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.SourceID = data.slice(start, i);
			readHeader();
		}

		if (header == 12) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.Transaction.Tags length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.Transaction.Tags length ' + l + ' exceeds ' + colferListMax + ' elements');

			this.Tags = new Array(l);
			for (var n = 0; n < l; ++n) {
				var size = readVarint();
				if (size < 0)
					throw new Error('colfer: colfer.Transaction.Tags element ' + this.Tags.length + ' size exceeds Number.MAX_SAFE_INTEGER');
				else if (size > colferSizeMax)
					throw new Error('colfer: colfer.Transaction.Tags element ' + this.Tags.length + ' size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

				var start = i;
				i += size;
				if (i > data.length) throw new Error(EOF);
				this.Tags[n] = decodeUTF8(data.subarray(start, i));
			}
			readHeader();
		}

		if (header == 13) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Transaction.TaxDisposition size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Transaction.TaxDisposition size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.TaxDisposition = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 14) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Transaction.Ticker size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Transaction.Ticker size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.Ticker = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 15) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TotalValue = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.Transaction serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Holding = function(init) {

		this.Date = null;
		this.Date_ns = 0;

		this.Ticker = '';

		this.Shares = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.Holding.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if ((this.Date && this.Date.getTime()) || this.Date_ns) {
			var ms = this.Date ? this.Date.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.Date_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/Holding field Date_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 0 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 0;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if (this.Ticker) {
			buf[i++] = 1;
			var utf8 = encodeUTF8(this.Ticker);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.Shares) {
			buf[i++] = 2;
			view.setFloat64(i, this.Shares);
			i += 8;
		} else if (Number.isNaN(this.Shares)) {
			buf.set([2, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.Holding serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Holding.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.Date = new Date(ms);
			this.Date_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (0 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field Date exceeds ECMA Date range');
			this.Date = new Date(ms);
			this.Date_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 1) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Holding.Ticker size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Holding.Ticker size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.Ticker = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Shares = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.Holding serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Portfolio = function(init) {

		this.ID = new Uint8Array(0);

		this.UserID = '';

		this.Name = '';

		this.StartDate = null;
		this.StartDate_ns = 0;

		this.EndDate = null;
		this.EndDate_ns = 0;

		this.Benchmark = '';

		this.StrategyShortcode = '';

		this.StrategyArguments = '';

		this.Notifications = 0;

		this.Transactions = [];

		this.CurrentHoldings = [];

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property Transactions will be replaced with a new colfer.Transaction.
	// All null entries in property CurrentHoldings will be replaced with a new colfer.Holding.
	this.Portfolio.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.ID && this.ID.length) {
			buf[i++] = 0;
			var b = this.ID;
			i = encodeVarint(buf, i, b.length);
			buf.set(b, i);
			i += b.length;
		}

		if (this.UserID) {
			buf[i++] = 1;
			var utf8 = encodeUTF8(this.UserID);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.Name) {
			buf[i++] = 2;
			var utf8 = encodeUTF8(this.Name);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if ((this.StartDate && this.StartDate.getTime()) || this.StartDate_ns) {
			var ms = this.StartDate ? this.StartDate.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.StartDate_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/Portfolio field StartDate_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 3 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 3;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if ((this.EndDate && this.EndDate.getTime()) || this.EndDate_ns) {
			var ms = this.EndDate ? this.EndDate.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.EndDate_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/Portfolio field EndDate_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 4 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 4;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if (this.Benchmark) {
			buf[i++] = 5;
			var utf8 = encodeUTF8(this.Benchmark);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.StrategyShortcode) {
			buf[i++] = 6;
			var utf8 = encodeUTF8(this.StrategyShortcode);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.StrategyArguments) {
			buf[i++] = 7;
			var utf8 = encodeUTF8(this.StrategyArguments);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.Notifications) {
			if (this.Notifications < 0) {
				buf[i++] = 8 | 128;
				if (this.Notifications < -2147483648)
					throw new Error('colfer: colfer/Portfolio field Notifications exceeds 32-bit range');
				i = encodeVarint(buf, i, -this.Notifications);
			} else {
				buf[i++] = 8; 
				if (this.Notifications > 2147483647)
					throw new Error('colfer: colfer/Portfolio field Notifications exceeds 32-bit range');
				i = encodeVarint(buf, i, this.Notifications);
			}
		}

		if (this.Transactions && this.Transactions.length) {
			var a = this.Transactions;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.Portfolio.Transactions length exceeds colferListMax');
			buf[i++] = 9;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.Transaction();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.CurrentHoldings && this.CurrentHoldings.length) {
			var a = this.CurrentHoldings;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.Portfolio.CurrentHoldings length exceeds colferListMax');
			buf[i++] = 10;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.Holding();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.Portfolio serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Portfolio.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Portfolio.ID size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Portfolio.ID size ' + size + ' exceeds ' + colferSizeMax + ' bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.ID = data.slice(start, i);
			readHeader();
		}

		if (header == 1) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Portfolio.UserID size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Portfolio.UserID size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.UserID = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 2) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Portfolio.Name size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Portfolio.Name size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.Name = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.StartDate = new Date(ms);
			this.StartDate_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (3 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field StartDate exceeds ECMA Date range');
			this.StartDate = new Date(ms);
			this.StartDate_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 4) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.EndDate = new Date(ms);
			this.EndDate_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (4 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field EndDate exceeds ECMA Date range');
			this.EndDate = new Date(ms);
			this.EndDate_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 5) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Portfolio.Benchmark size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Portfolio.Benchmark size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.Benchmark = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 6) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Portfolio.StrategyShortcode size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Portfolio.StrategyShortcode size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.StrategyShortcode = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 7) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Portfolio.StrategyArguments size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Portfolio.StrategyArguments size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.StrategyArguments = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 8) {
			var x = readVarint();
			if (x < 0) throw new Error('colfer: colfer/Portfolio field Notifications exceeds Number.MAX_SAFE_INTEGER');
			this.Notifications = x;
			readHeader();
		} else if (header == (8 | 128)) {
			var x = readVarint();
			if (x < 0) throw new Error('colfer: colfer/Portfolio field Notifications exceeds Number.MAX_SAFE_INTEGER');
			this.Notifications = -1 * x;
			readHeader();
		}

		if (header == 9) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.Portfolio.Transactions length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.Portfolio.Transactions length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.Transaction();
				i += o.unmarshal(data.subarray(i));
				this.Transactions[n] = o;
			}
			readHeader();
		}

		if (header == 10) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.Portfolio.CurrentHoldings length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.Portfolio.CurrentHoldings length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.Holding();
				i += o.unmarshal(data.subarray(i));
				this.CurrentHoldings[n] = o;
			}
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.Portfolio serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.DrawDown = function(init) {

		this.Begin = null;
		this.Begin_ns = 0;

		this.End = null;
		this.End_ns = 0;

		this.Recovery = null;
		this.Recovery_ns = 0;

		this.LossPercent = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.DrawDown.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if ((this.Begin && this.Begin.getTime()) || this.Begin_ns) {
			var ms = this.Begin ? this.Begin.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.Begin_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/DrawDown field Begin_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 0 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 0;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if ((this.End && this.End.getTime()) || this.End_ns) {
			var ms = this.End ? this.End.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.End_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/DrawDown field End_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 1 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 1;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if ((this.Recovery && this.Recovery.getTime()) || this.Recovery_ns) {
			var ms = this.Recovery ? this.Recovery.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.Recovery_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/DrawDown field Recovery_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 2 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 2;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if (this.LossPercent) {
			buf[i++] = 3;
			view.setFloat64(i, this.LossPercent);
			i += 8;
		} else if (Number.isNaN(this.LossPercent)) {
			buf.set([3, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.DrawDown serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.DrawDown.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.Begin = new Date(ms);
			this.Begin_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (0 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field Begin exceeds ECMA Date range');
			this.Begin = new Date(ms);
			this.Begin_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.End = new Date(ms);
			this.End_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (1 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field End exceeds ECMA Date range');
			this.End = new Date(ms);
			this.End_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.Recovery = new Date(ms);
			this.Recovery_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (2 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field Recovery exceeds ECMA Date range');
			this.Recovery = new Date(ms);
			this.Recovery_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.LossPercent = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.DrawDown serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.AnnualReturn = function(init) {

		this.Year = 0;

		this.Return = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.AnnualReturn.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.Year) {
			if (this.Year > 65535 || this.Year < 0)
				throw new Error('colfer: colfer/AnnualReturn field Year out of reach: ' + this.Year);
			if (this.Year < 256) {
				buf[i++] = 0 | 128;
				buf[i++] = this.Year;
			} else {
				buf[i++] = 0;
				buf[i++] = this.Year >>> 0;
				buf[i++] = this.Year & 255;
			}
		}

		if (this.Return) {
			if (this.Return > 3.4028234663852886E38 || this.Return < -3.4028234663852886E38)
				throw new Error('colfer: colfer/AnnualReturn field Return exceeds 32-bit range');
			buf[i++] = 1;
			view.setFloat32(i, this.Return);
			i += 4;
		} else if (Number.isNaN(this.Return)) {
			buf.set([1, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.AnnualReturn serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.AnnualReturn.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 2 >= data.length) throw new Error(EOF);
			this.Year = (data[i++] << 8) | data[i++];
			header = data[i++];
		} else if (header == (0 | 128)) {
			if (i + 1 >= data.length) throw new Error(EOF);
			this.Year = data[i++];
			header = data[i++];
		}

		if (header == 1) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.Return = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.AnnualReturn serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Metrics = function(init) {

		this.AlphaSinceInception = 0;

		this.AvgDrawDown = 0;

		this.BestYear = null;

		this.BetaSinceInception = 0;

		this.DownsideDeviationSinceInception = 0;

		this.ExcessKurtosisSinceInception = 0;

		this.FinalBalance = 0;

		this.SharpeRatioSinceInception = 0;

		this.Skewness = 0;

		this.SortinoRatioSinceInception = 0;

		this.StdDevSinceInception = 0;

		this.TotalDeposited = 0;

		this.TotalWithdrawn = 0;

		this.UlcerIndexAvg = 0;

		this.UlcerIndexP50 = 0;

		this.UlcerIndexP90 = 0;

		this.UlcerIndexP99 = 0;

		this.WorstYear = null;

		this.DynamicWithdrawalRateSinceInception = 0;

		this.PerpetualWithdrawalRateSinceInception = 0;

		this.SafeWithdrawalRateSinceInception = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.Metrics.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.AlphaSinceInception) {
			buf[i++] = 0;
			view.setFloat64(i, this.AlphaSinceInception);
			i += 8;
		} else if (Number.isNaN(this.AlphaSinceInception)) {
			buf.set([0, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.AvgDrawDown) {
			buf[i++] = 1;
			view.setFloat64(i, this.AvgDrawDown);
			i += 8;
		} else if (Number.isNaN(this.AvgDrawDown)) {
			buf.set([1, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.BestYear) {
			buf[i++] = 2;
			var b = this.BestYear.marshal();
			buf.set(b, i);
			i += b.length;
		}

		if (this.BetaSinceInception) {
			buf[i++] = 3;
			view.setFloat64(i, this.BetaSinceInception);
			i += 8;
		} else if (Number.isNaN(this.BetaSinceInception)) {
			buf.set([3, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.DownsideDeviationSinceInception) {
			buf[i++] = 4;
			view.setFloat64(i, this.DownsideDeviationSinceInception);
			i += 8;
		} else if (Number.isNaN(this.DownsideDeviationSinceInception)) {
			buf.set([4, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.ExcessKurtosisSinceInception) {
			buf[i++] = 5;
			view.setFloat64(i, this.ExcessKurtosisSinceInception);
			i += 8;
		} else if (Number.isNaN(this.ExcessKurtosisSinceInception)) {
			buf.set([5, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.FinalBalance) {
			buf[i++] = 6;
			view.setFloat64(i, this.FinalBalance);
			i += 8;
		} else if (Number.isNaN(this.FinalBalance)) {
			buf.set([6, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.SharpeRatioSinceInception) {
			buf[i++] = 7;
			view.setFloat64(i, this.SharpeRatioSinceInception);
			i += 8;
		} else if (Number.isNaN(this.SharpeRatioSinceInception)) {
			buf.set([7, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.Skewness) {
			buf[i++] = 8;
			view.setFloat64(i, this.Skewness);
			i += 8;
		} else if (Number.isNaN(this.Skewness)) {
			buf.set([8, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.SortinoRatioSinceInception) {
			buf[i++] = 9;
			view.setFloat64(i, this.SortinoRatioSinceInception);
			i += 8;
		} else if (Number.isNaN(this.SortinoRatioSinceInception)) {
			buf.set([9, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.StdDevSinceInception) {
			buf[i++] = 10;
			view.setFloat64(i, this.StdDevSinceInception);
			i += 8;
		} else if (Number.isNaN(this.StdDevSinceInception)) {
			buf.set([10, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TotalDeposited) {
			buf[i++] = 11;
			view.setFloat64(i, this.TotalDeposited);
			i += 8;
		} else if (Number.isNaN(this.TotalDeposited)) {
			buf.set([11, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TotalWithdrawn) {
			buf[i++] = 12;
			view.setFloat64(i, this.TotalWithdrawn);
			i += 8;
		} else if (Number.isNaN(this.TotalWithdrawn)) {
			buf.set([12, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.UlcerIndexAvg) {
			buf[i++] = 13;
			view.setFloat64(i, this.UlcerIndexAvg);
			i += 8;
		} else if (Number.isNaN(this.UlcerIndexAvg)) {
			buf.set([13, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.UlcerIndexP50) {
			buf[i++] = 14;
			view.setFloat64(i, this.UlcerIndexP50);
			i += 8;
		} else if (Number.isNaN(this.UlcerIndexP50)) {
			buf.set([14, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.UlcerIndexP90) {
			buf[i++] = 15;
			view.setFloat64(i, this.UlcerIndexP90);
			i += 8;
		} else if (Number.isNaN(this.UlcerIndexP90)) {
			buf.set([15, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.UlcerIndexP99) {
			buf[i++] = 16;
			view.setFloat64(i, this.UlcerIndexP99);
			i += 8;
		} else if (Number.isNaN(this.UlcerIndexP99)) {
			buf.set([16, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.WorstYear) {
			buf[i++] = 17;
			var b = this.WorstYear.marshal();
			buf.set(b, i);
			i += b.length;
		}

		if (this.DynamicWithdrawalRateSinceInception) {
			buf[i++] = 18;
			view.setFloat64(i, this.DynamicWithdrawalRateSinceInception);
			i += 8;
		} else if (Number.isNaN(this.DynamicWithdrawalRateSinceInception)) {
			buf.set([18, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.PerpetualWithdrawalRateSinceInception) {
			buf[i++] = 19;
			view.setFloat64(i, this.PerpetualWithdrawalRateSinceInception);
			i += 8;
		} else if (Number.isNaN(this.PerpetualWithdrawalRateSinceInception)) {
			buf.set([19, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.SafeWithdrawalRateSinceInception) {
			buf[i++] = 20;
			view.setFloat64(i, this.SafeWithdrawalRateSinceInception);
			i += 8;
		} else if (Number.isNaN(this.SafeWithdrawalRateSinceInception)) {
			buf.set([20, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.Metrics serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Metrics.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.AlphaSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.AvgDrawDown = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			var o = new colfer.AnnualReturn();
			i += o.unmarshal(data.subarray(i));
			this.BestYear = o;
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.BetaSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 4) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.DownsideDeviationSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 5) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.ExcessKurtosisSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 6) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.FinalBalance = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 7) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.SharpeRatioSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 8) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Skewness = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 9) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.SortinoRatioSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 10) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.StdDevSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 11) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TotalDeposited = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 12) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TotalWithdrawn = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 13) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.UlcerIndexAvg = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 14) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.UlcerIndexP50 = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 15) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.UlcerIndexP90 = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 16) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.UlcerIndexP99 = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 17) {
			var o = new colfer.AnnualReturn();
			i += o.unmarshal(data.subarray(i));
			this.WorstYear = o;
			readHeader();
		}

		if (header == 18) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.DynamicWithdrawalRateSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 19) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.PerpetualWithdrawalRateSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 20) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.SafeWithdrawalRateSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.Metrics serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Performance = function(init) {

		this.PortfolioID = new Uint8Array(0);

		this.PeriodStart = null;
		this.PeriodStart_ns = 0;

		this.PeriodEnd = null;
		this.PeriodEnd_ns = 0;

		this.ComputedOn = null;
		this.ComputedOn_ns = 0;

		this.CurrentAssets = [];

		this.Measurements = [];

		this.DrawDowns = [];

		this.PortfolioReturns = null;

		this.BenchmarkReturns = null;

		this.PortfolioMetrics = null;

		this.BenchmarkMetrics = null;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property CurrentAssets will be replaced with a new colfer.ReportableHolding.
	// All null entries in property Measurements will be replaced with a new colfer.PerformanceMeasurement.
	// All null entries in property DrawDowns will be replaced with a new colfer.DrawDown.
	this.Performance.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.PortfolioID && this.PortfolioID.length) {
			buf[i++] = 0;
			var b = this.PortfolioID;
			i = encodeVarint(buf, i, b.length);
			buf.set(b, i);
			i += b.length;
		}

		if ((this.PeriodStart && this.PeriodStart.getTime()) || this.PeriodStart_ns) {
			var ms = this.PeriodStart ? this.PeriodStart.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.PeriodStart_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/Performance field PeriodStart_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 1 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 1;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if ((this.PeriodEnd && this.PeriodEnd.getTime()) || this.PeriodEnd_ns) {
			var ms = this.PeriodEnd ? this.PeriodEnd.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.PeriodEnd_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/Performance field PeriodEnd_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 2 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 2;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if ((this.ComputedOn && this.ComputedOn.getTime()) || this.ComputedOn_ns) {
			var ms = this.ComputedOn ? this.ComputedOn.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.ComputedOn_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/Performance field ComputedOn_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 3 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 3;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if (this.CurrentAssets && this.CurrentAssets.length) {
			var a = this.CurrentAssets;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.Performance.CurrentAssets length exceeds colferListMax');
			buf[i++] = 4;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.ReportableHolding();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.Measurements && this.Measurements.length) {
			var a = this.Measurements;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.Performance.Measurements length exceeds colferListMax');
			buf[i++] = 5;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.PerformanceMeasurement();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.DrawDowns && this.DrawDowns.length) {
			var a = this.DrawDowns;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.Performance.DrawDowns length exceeds colferListMax');
			buf[i++] = 6;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.DrawDown();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.PortfolioReturns) {
			buf[i++] = 7;
			var b = this.PortfolioReturns.marshal();
			buf.set(b, i);
			i += b.length;
		}

		if (this.BenchmarkReturns) {
			buf[i++] = 8;
			var b = this.BenchmarkReturns.marshal();
			buf.set(b, i);
			i += b.length;
		}

		if (this.PortfolioMetrics) {
			buf[i++] = 9;
			var b = this.PortfolioMetrics.marshal();
			buf.set(b, i);
			i += b.length;
		}

		if (this.BenchmarkMetrics) {
			buf[i++] = 10;
			var b = this.BenchmarkMetrics.marshal();
			buf.set(b, i);
			i += b.length;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.Performance serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Performance.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.Performance.PortfolioID size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.Performance.PortfolioID size ' + size + ' exceeds ' + colferSizeMax + ' bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.PortfolioID = data.slice(start, i);
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.PeriodStart = new Date(ms);
			this.PeriodStart_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (1 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field PeriodStart exceeds ECMA Date range');
			this.PeriodStart = new Date(ms);
			this.PeriodStart_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.PeriodEnd = new Date(ms);
			this.PeriodEnd_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (2 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field PeriodEnd exceeds ECMA Date range');
			this.PeriodEnd = new Date(ms);
			this.PeriodEnd_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.ComputedOn = new Date(ms);
			this.ComputedOn_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (3 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field ComputedOn exceeds ECMA Date range');
			this.ComputedOn = new Date(ms);
			this.ComputedOn_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 4) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.Performance.CurrentAssets length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.Performance.CurrentAssets length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.ReportableHolding();
				i += o.unmarshal(data.subarray(i));
				this.CurrentAssets[n] = o;
			}
			readHeader();
		}

		if (header == 5) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.Performance.Measurements length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.Performance.Measurements length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.PerformanceMeasurement();
				i += o.unmarshal(data.subarray(i));
				this.Measurements[n] = o;
			}
			readHeader();
		}

		if (header == 6) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.Performance.DrawDowns length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.Performance.DrawDowns length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.DrawDown();
				i += o.unmarshal(data.subarray(i));
				this.DrawDowns[n] = o;
			}
			readHeader();
		}

		if (header == 7) {
			var o = new colfer.Returns();
			i += o.unmarshal(data.subarray(i));
			this.PortfolioReturns = o;
			readHeader();
		}

		if (header == 8) {
			var o = new colfer.Returns();
			i += o.unmarshal(data.subarray(i));
			this.BenchmarkReturns = o;
			readHeader();
		}

		if (header == 9) {
			var o = new colfer.Metrics();
			i += o.unmarshal(data.subarray(i));
			this.PortfolioMetrics = o;
			readHeader();
		}

		if (header == 10) {
			var o = new colfer.Metrics();
			i += o.unmarshal(data.subarray(i));
			this.BenchmarkMetrics = o;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.Performance serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.PerformanceMeasurementItem = function(init) {

		this.Time = null;
		this.Time_ns = 0;

		this.Value1 = 0;

		this.Value2 = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.PerformanceMeasurementItem.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if ((this.Time && this.Time.getTime()) || this.Time_ns) {
			var ms = this.Time ? this.Time.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.Time_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/PerformanceMeasurementItem field Time_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 0 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 0;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if (this.Value1) {
			buf[i++] = 1;
			view.setFloat64(i, this.Value1);
			i += 8;
		} else if (Number.isNaN(this.Value1)) {
			buf.set([1, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.Value2) {
			buf[i++] = 2;
			view.setFloat64(i, this.Value2);
			i += 8;
		} else if (Number.isNaN(this.Value2)) {
			buf.set([2, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.PerformanceMeasurementItem serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.PerformanceMeasurementItem.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.Time = new Date(ms);
			this.Time_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (0 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field Time exceeds ECMA Date range');
			this.Time = new Date(ms);
			this.Time_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Value1 = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Value2 = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.PerformanceMeasurementItem serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.PerformanceMeasurementItemList = function(init) {

		this.Items = [];

		this.FieldNames = [];

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property Items will be replaced with a new colfer.PerformanceMeasurementItem.
	// All null entries in property FieldNames will be replaced with an empty String.
	this.PerformanceMeasurementItemList.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.Items && this.Items.length) {
			var a = this.Items;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.PerformanceMeasurementItemList.Items length exceeds colferListMax');
			buf[i++] = 0;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.PerformanceMeasurementItem();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.FieldNames && this.FieldNames.length) {
			var a = this.FieldNames;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.PerformanceMeasurementItemList.FieldNames length exceeds colferListMax');
			buf[i++] = 1;
			i = encodeVarint(buf, i, a.length);

			a.forEach(function(s, si) {
				if (s == null) {
					s = "";
					a[si] = s;
				}
				var utf8 = encodeUTF8(s);
				i = encodeVarint(buf, i, utf8.length);
				buf.set(utf8, i);
				i += utf8.length;
			});
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.PerformanceMeasurementItemList serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.PerformanceMeasurementItemList.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.PerformanceMeasurementItemList.Items length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.PerformanceMeasurementItemList.Items length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.PerformanceMeasurementItem();
				i += o.unmarshal(data.subarray(i));
				this.Items[n] = o;
			}
			readHeader();
		}

		if (header == 1) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.PerformanceMeasurementItemList.FieldNames length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.PerformanceMeasurementItemList.FieldNames length ' + l + ' exceeds ' + colferListMax + ' elements');

			this.FieldNames = new Array(l);
			for (var n = 0; n < l; ++n) {
				var size = readVarint();
				if (size < 0)
					throw new Error('colfer: colfer.PerformanceMeasurementItemList.FieldNames element ' + this.FieldNames.length + ' size exceeds Number.MAX_SAFE_INTEGER');
				else if (size > colferSizeMax)
					throw new Error('colfer: colfer.PerformanceMeasurementItemList.FieldNames element ' + this.FieldNames.length + ' size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

				var start = i;
				i += size;
				if (i > data.length) throw new Error(EOF);
				this.FieldNames[n] = decodeUTF8(data.subarray(start, i));
			}
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.PerformanceMeasurementItemList serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.PerformanceMeasurement = function(init) {

		this.Time = null;
		this.Time_ns = 0;

		this.Value = 0;

		this.BenchmarkValue = 0;

		this.RiskFreeValue = 0;

		this.StrategyGrowthOf10K = 0;

		this.BenchmarkGrowthOf10K = 0;

		this.RiskFreeGrowthOf10K = 0;

		this.Holdings = [];

		this.TotalDeposited = 0;

		this.TotalWithdrawn = 0;
		// Time-weighted rate of return
		this.TWRROneDay = 0;

		this.TWRROneWeek = 0;

		this.TWRROneMonth = 0;

		this.TWRRThreeMonth = 0;

		this.TWRROneYear = 0;

		this.TWRRThreeYear = 0;

		this.TWRRFiveYear = 0;

		this.TWRRTenYear = 0;
		// Money-weighted rate of return
		this.MWRROneDay = 0;

		this.MWRROneWeek = 0;

		this.MWRROneMonth = 0;

		this.MWRRThreeMonth = 0;

		this.MWRROneYear = 0;

		this.MWRRThreeYear = 0;

		this.MWRRFiveYear = 0;

		this.MWRRTenYear = 0;
		// active return
		this.ActiveReturnOneYear = 0;

		this.ActiveReturnThreeYear = 0;

		this.ActiveReturnFiveYear = 0;

		this.ActiveReturnTenYear = 0;
		// alpha
		this.AlphaOneYear = 0;

		this.AlphaThreeYear = 0;

		this.AlphaFiveYear = 0;

		this.AlphaTenYear = 0;
		// beta
		this.BetaOneYear = 0;

		this.BetaThreeYear = 0;

		this.BetaFiveYear = 0;

		this.BetaTenYear = 0;
		// ratios
		this.CalmarRatio = 0;

		this.DownsideDeviation = 0;

		this.InformationRatio = 0;

		this.KRatio = 0;

		this.KellerRatio = 0;

		this.SharpeRatio = 0;

		this.SortinoRatio = 0;

		this.StdDev = 0;

		this.TreynorRatio = 0;

		this.UlcerIndex = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property Holdings will be replaced with a new colfer.ReportableHolding.
	this.PerformanceMeasurement.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if ((this.Time && this.Time.getTime()) || this.Time_ns) {
			var ms = this.Time ? this.Time.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.Time_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/PerformanceMeasurement field Time_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 0 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 0;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if (this.Value) {
			buf[i++] = 1;
			view.setFloat64(i, this.Value);
			i += 8;
		} else if (Number.isNaN(this.Value)) {
			buf.set([1, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.BenchmarkValue) {
			buf[i++] = 2;
			view.setFloat64(i, this.BenchmarkValue);
			i += 8;
		} else if (Number.isNaN(this.BenchmarkValue)) {
			buf.set([2, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.RiskFreeValue) {
			buf[i++] = 3;
			view.setFloat64(i, this.RiskFreeValue);
			i += 8;
		} else if (Number.isNaN(this.RiskFreeValue)) {
			buf.set([3, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.StrategyGrowthOf10K) {
			buf[i++] = 4;
			view.setFloat64(i, this.StrategyGrowthOf10K);
			i += 8;
		} else if (Number.isNaN(this.StrategyGrowthOf10K)) {
			buf.set([4, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.BenchmarkGrowthOf10K) {
			buf[i++] = 5;
			view.setFloat64(i, this.BenchmarkGrowthOf10K);
			i += 8;
		} else if (Number.isNaN(this.BenchmarkGrowthOf10K)) {
			buf.set([5, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.RiskFreeGrowthOf10K) {
			buf[i++] = 6;
			view.setFloat64(i, this.RiskFreeGrowthOf10K);
			i += 8;
		} else if (Number.isNaN(this.RiskFreeGrowthOf10K)) {
			buf.set([6, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.Holdings && this.Holdings.length) {
			var a = this.Holdings;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.PerformanceMeasurement.Holdings length exceeds colferListMax');
			buf[i++] = 7;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.ReportableHolding();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.TotalDeposited) {
			buf[i++] = 8;
			view.setFloat64(i, this.TotalDeposited);
			i += 8;
		} else if (Number.isNaN(this.TotalDeposited)) {
			buf.set([8, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TotalWithdrawn) {
			buf[i++] = 9;
			view.setFloat64(i, this.TotalWithdrawn);
			i += 8;
		} else if (Number.isNaN(this.TotalWithdrawn)) {
			buf.set([9, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TWRROneDay) {
			if (this.TWRROneDay > 3.4028234663852886E38 || this.TWRROneDay < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field TWRROneDay exceeds 32-bit range');
			buf[i++] = 10;
			view.setFloat32(i, this.TWRROneDay);
			i += 4;
		} else if (Number.isNaN(this.TWRROneDay)) {
			buf.set([10, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.TWRROneWeek) {
			if (this.TWRROneWeek > 3.4028234663852886E38 || this.TWRROneWeek < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field TWRROneWeek exceeds 32-bit range');
			buf[i++] = 11;
			view.setFloat32(i, this.TWRROneWeek);
			i += 4;
		} else if (Number.isNaN(this.TWRROneWeek)) {
			buf.set([11, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.TWRROneMonth) {
			if (this.TWRROneMonth > 3.4028234663852886E38 || this.TWRROneMonth < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field TWRROneMonth exceeds 32-bit range');
			buf[i++] = 12;
			view.setFloat32(i, this.TWRROneMonth);
			i += 4;
		} else if (Number.isNaN(this.TWRROneMonth)) {
			buf.set([12, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.TWRRThreeMonth) {
			if (this.TWRRThreeMonth > 3.4028234663852886E38 || this.TWRRThreeMonth < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field TWRRThreeMonth exceeds 32-bit range');
			buf[i++] = 13;
			view.setFloat32(i, this.TWRRThreeMonth);
			i += 4;
		} else if (Number.isNaN(this.TWRRThreeMonth)) {
			buf.set([13, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.TWRROneYear) {
			if (this.TWRROneYear > 3.4028234663852886E38 || this.TWRROneYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field TWRROneYear exceeds 32-bit range');
			buf[i++] = 14;
			view.setFloat32(i, this.TWRROneYear);
			i += 4;
		} else if (Number.isNaN(this.TWRROneYear)) {
			buf.set([14, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.TWRRThreeYear) {
			if (this.TWRRThreeYear > 3.4028234663852886E38 || this.TWRRThreeYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field TWRRThreeYear exceeds 32-bit range');
			buf[i++] = 15;
			view.setFloat32(i, this.TWRRThreeYear);
			i += 4;
		} else if (Number.isNaN(this.TWRRThreeYear)) {
			buf.set([15, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.TWRRFiveYear) {
			if (this.TWRRFiveYear > 3.4028234663852886E38 || this.TWRRFiveYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field TWRRFiveYear exceeds 32-bit range');
			buf[i++] = 16;
			view.setFloat32(i, this.TWRRFiveYear);
			i += 4;
		} else if (Number.isNaN(this.TWRRFiveYear)) {
			buf.set([16, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.TWRRTenYear) {
			if (this.TWRRTenYear > 3.4028234663852886E38 || this.TWRRTenYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field TWRRTenYear exceeds 32-bit range');
			buf[i++] = 17;
			view.setFloat32(i, this.TWRRTenYear);
			i += 4;
		} else if (Number.isNaN(this.TWRRTenYear)) {
			buf.set([17, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.MWRROneDay) {
			if (this.MWRROneDay > 3.4028234663852886E38 || this.MWRROneDay < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field MWRROneDay exceeds 32-bit range');
			buf[i++] = 18;
			view.setFloat32(i, this.MWRROneDay);
			i += 4;
		} else if (Number.isNaN(this.MWRROneDay)) {
			buf.set([18, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.MWRROneWeek) {
			if (this.MWRROneWeek > 3.4028234663852886E38 || this.MWRROneWeek < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field MWRROneWeek exceeds 32-bit range');
			buf[i++] = 19;
			view.setFloat32(i, this.MWRROneWeek);
			i += 4;
		} else if (Number.isNaN(this.MWRROneWeek)) {
			buf.set([19, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.MWRROneMonth) {
			if (this.MWRROneMonth > 3.4028234663852886E38 || this.MWRROneMonth < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field MWRROneMonth exceeds 32-bit range');
			buf[i++] = 20;
			view.setFloat32(i, this.MWRROneMonth);
			i += 4;
		} else if (Number.isNaN(this.MWRROneMonth)) {
			buf.set([20, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.MWRRThreeMonth) {
			if (this.MWRRThreeMonth > 3.4028234663852886E38 || this.MWRRThreeMonth < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field MWRRThreeMonth exceeds 32-bit range');
			buf[i++] = 21;
			view.setFloat32(i, this.MWRRThreeMonth);
			i += 4;
		} else if (Number.isNaN(this.MWRRThreeMonth)) {
			buf.set([21, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.MWRROneYear) {
			if (this.MWRROneYear > 3.4028234663852886E38 || this.MWRROneYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field MWRROneYear exceeds 32-bit range');
			buf[i++] = 22;
			view.setFloat32(i, this.MWRROneYear);
			i += 4;
		} else if (Number.isNaN(this.MWRROneYear)) {
			buf.set([22, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.MWRRThreeYear) {
			if (this.MWRRThreeYear > 3.4028234663852886E38 || this.MWRRThreeYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field MWRRThreeYear exceeds 32-bit range');
			buf[i++] = 23;
			view.setFloat32(i, this.MWRRThreeYear);
			i += 4;
		} else if (Number.isNaN(this.MWRRThreeYear)) {
			buf.set([23, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.MWRRFiveYear) {
			if (this.MWRRFiveYear > 3.4028234663852886E38 || this.MWRRFiveYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field MWRRFiveYear exceeds 32-bit range');
			buf[i++] = 24;
			view.setFloat32(i, this.MWRRFiveYear);
			i += 4;
		} else if (Number.isNaN(this.MWRRFiveYear)) {
			buf.set([24, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.MWRRTenYear) {
			if (this.MWRRTenYear > 3.4028234663852886E38 || this.MWRRTenYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field MWRRTenYear exceeds 32-bit range');
			buf[i++] = 25;
			view.setFloat32(i, this.MWRRTenYear);
			i += 4;
		} else if (Number.isNaN(this.MWRRTenYear)) {
			buf.set([25, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.ActiveReturnOneYear) {
			if (this.ActiveReturnOneYear > 3.4028234663852886E38 || this.ActiveReturnOneYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field ActiveReturnOneYear exceeds 32-bit range');
			buf[i++] = 26;
			view.setFloat32(i, this.ActiveReturnOneYear);
			i += 4;
		} else if (Number.isNaN(this.ActiveReturnOneYear)) {
			buf.set([26, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.ActiveReturnThreeYear) {
			if (this.ActiveReturnThreeYear > 3.4028234663852886E38 || this.ActiveReturnThreeYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field ActiveReturnThreeYear exceeds 32-bit range');
			buf[i++] = 27;
			view.setFloat32(i, this.ActiveReturnThreeYear);
			i += 4;
		} else if (Number.isNaN(this.ActiveReturnThreeYear)) {
			buf.set([27, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.ActiveReturnFiveYear) {
			if (this.ActiveReturnFiveYear > 3.4028234663852886E38 || this.ActiveReturnFiveYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field ActiveReturnFiveYear exceeds 32-bit range');
			buf[i++] = 28;
			view.setFloat32(i, this.ActiveReturnFiveYear);
			i += 4;
		} else if (Number.isNaN(this.ActiveReturnFiveYear)) {
			buf.set([28, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.ActiveReturnTenYear) {
			if (this.ActiveReturnTenYear > 3.4028234663852886E38 || this.ActiveReturnTenYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field ActiveReturnTenYear exceeds 32-bit range');
			buf[i++] = 29;
			view.setFloat32(i, this.ActiveReturnTenYear);
			i += 4;
		} else if (Number.isNaN(this.ActiveReturnTenYear)) {
			buf.set([29, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.AlphaOneYear) {
			if (this.AlphaOneYear > 3.4028234663852886E38 || this.AlphaOneYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field AlphaOneYear exceeds 32-bit range');
			buf[i++] = 30;
			view.setFloat32(i, this.AlphaOneYear);
			i += 4;
		} else if (Number.isNaN(this.AlphaOneYear)) {
			buf.set([30, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.AlphaThreeYear) {
			if (this.AlphaThreeYear > 3.4028234663852886E38 || this.AlphaThreeYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field AlphaThreeYear exceeds 32-bit range');
			buf[i++] = 31;
			view.setFloat32(i, this.AlphaThreeYear);
			i += 4;
		} else if (Number.isNaN(this.AlphaThreeYear)) {
			buf.set([31, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.AlphaFiveYear) {
			if (this.AlphaFiveYear > 3.4028234663852886E38 || this.AlphaFiveYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field AlphaFiveYear exceeds 32-bit range');
			buf[i++] = 32;
			view.setFloat32(i, this.AlphaFiveYear);
			i += 4;
		} else if (Number.isNaN(this.AlphaFiveYear)) {
			buf.set([32, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.AlphaTenYear) {
			if (this.AlphaTenYear > 3.4028234663852886E38 || this.AlphaTenYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field AlphaTenYear exceeds 32-bit range');
			buf[i++] = 33;
			view.setFloat32(i, this.AlphaTenYear);
			i += 4;
		} else if (Number.isNaN(this.AlphaTenYear)) {
			buf.set([33, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.BetaOneYear) {
			if (this.BetaOneYear > 3.4028234663852886E38 || this.BetaOneYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field BetaOneYear exceeds 32-bit range');
			buf[i++] = 34;
			view.setFloat32(i, this.BetaOneYear);
			i += 4;
		} else if (Number.isNaN(this.BetaOneYear)) {
			buf.set([34, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.BetaThreeYear) {
			if (this.BetaThreeYear > 3.4028234663852886E38 || this.BetaThreeYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field BetaThreeYear exceeds 32-bit range');
			buf[i++] = 35;
			view.setFloat32(i, this.BetaThreeYear);
			i += 4;
		} else if (Number.isNaN(this.BetaThreeYear)) {
			buf.set([35, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.BetaFiveYear) {
			if (this.BetaFiveYear > 3.4028234663852886E38 || this.BetaFiveYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field BetaFiveYear exceeds 32-bit range');
			buf[i++] = 36;
			view.setFloat32(i, this.BetaFiveYear);
			i += 4;
		} else if (Number.isNaN(this.BetaFiveYear)) {
			buf.set([36, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.BetaTenYear) {
			if (this.BetaTenYear > 3.4028234663852886E38 || this.BetaTenYear < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field BetaTenYear exceeds 32-bit range');
			buf[i++] = 37;
			view.setFloat32(i, this.BetaTenYear);
			i += 4;
		} else if (Number.isNaN(this.BetaTenYear)) {
			buf.set([37, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.CalmarRatio) {
			if (this.CalmarRatio > 3.4028234663852886E38 || this.CalmarRatio < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field CalmarRatio exceeds 32-bit range');
			buf[i++] = 38;
			view.setFloat32(i, this.CalmarRatio);
			i += 4;
		} else if (Number.isNaN(this.CalmarRatio)) {
			buf.set([38, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.DownsideDeviation) {
			if (this.DownsideDeviation > 3.4028234663852886E38 || this.DownsideDeviation < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field DownsideDeviation exceeds 32-bit range');
			buf[i++] = 39;
			view.setFloat32(i, this.DownsideDeviation);
			i += 4;
		} else if (Number.isNaN(this.DownsideDeviation)) {
			buf.set([39, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.InformationRatio) {
			if (this.InformationRatio > 3.4028234663852886E38 || this.InformationRatio < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field InformationRatio exceeds 32-bit range');
			buf[i++] = 40;
			view.setFloat32(i, this.InformationRatio);
			i += 4;
		} else if (Number.isNaN(this.InformationRatio)) {
			buf.set([40, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.KRatio) {
			if (this.KRatio > 3.4028234663852886E38 || this.KRatio < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field KRatio exceeds 32-bit range');
			buf[i++] = 41;
			view.setFloat32(i, this.KRatio);
			i += 4;
		} else if (Number.isNaN(this.KRatio)) {
			buf.set([41, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.KellerRatio) {
			if (this.KellerRatio > 3.4028234663852886E38 || this.KellerRatio < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field KellerRatio exceeds 32-bit range');
			buf[i++] = 42;
			view.setFloat32(i, this.KellerRatio);
			i += 4;
		} else if (Number.isNaN(this.KellerRatio)) {
			buf.set([42, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.SharpeRatio) {
			if (this.SharpeRatio > 3.4028234663852886E38 || this.SharpeRatio < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field SharpeRatio exceeds 32-bit range');
			buf[i++] = 43;
			view.setFloat32(i, this.SharpeRatio);
			i += 4;
		} else if (Number.isNaN(this.SharpeRatio)) {
			buf.set([43, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.SortinoRatio) {
			if (this.SortinoRatio > 3.4028234663852886E38 || this.SortinoRatio < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field SortinoRatio exceeds 32-bit range');
			buf[i++] = 44;
			view.setFloat32(i, this.SortinoRatio);
			i += 4;
		} else if (Number.isNaN(this.SortinoRatio)) {
			buf.set([44, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.StdDev) {
			if (this.StdDev > 3.4028234663852886E38 || this.StdDev < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field StdDev exceeds 32-bit range');
			buf[i++] = 45;
			view.setFloat32(i, this.StdDev);
			i += 4;
		} else if (Number.isNaN(this.StdDev)) {
			buf.set([45, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.TreynorRatio) {
			if (this.TreynorRatio > 3.4028234663852886E38 || this.TreynorRatio < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field TreynorRatio exceeds 32-bit range');
			buf[i++] = 46;
			view.setFloat32(i, this.TreynorRatio);
			i += 4;
		} else if (Number.isNaN(this.TreynorRatio)) {
			buf.set([46, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.UlcerIndex) {
			if (this.UlcerIndex > 3.4028234663852886E38 || this.UlcerIndex < -3.4028234663852886E38)
				throw new Error('colfer: colfer/PerformanceMeasurement field UlcerIndex exceeds 32-bit range');
			buf[i++] = 47;
			view.setFloat32(i, this.UlcerIndex);
			i += 4;
		} else if (Number.isNaN(this.UlcerIndex)) {
			buf.set([47, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.PerformanceMeasurement serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.PerformanceMeasurement.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.Time = new Date(ms);
			this.Time_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (0 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field Time exceeds ECMA Date range');
			this.Time = new Date(ms);
			this.Time_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Value = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.BenchmarkValue = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.RiskFreeValue = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 4) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.StrategyGrowthOf10K = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 5) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.BenchmarkGrowthOf10K = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 6) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.RiskFreeGrowthOf10K = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 7) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.PerformanceMeasurement.Holdings length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.PerformanceMeasurement.Holdings length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.ReportableHolding();
				i += o.unmarshal(data.subarray(i));
				this.Holdings[n] = o;
			}
			readHeader();
		}

		if (header == 8) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TotalDeposited = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 9) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TotalWithdrawn = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 10) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.TWRROneDay = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 11) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.TWRROneWeek = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 12) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.TWRROneMonth = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 13) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.TWRRThreeMonth = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 14) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.TWRROneYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 15) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.TWRRThreeYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 16) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.TWRRFiveYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 17) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.TWRRTenYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 18) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.MWRROneDay = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 19) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.MWRROneWeek = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 20) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.MWRROneMonth = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 21) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.MWRRThreeMonth = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 22) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.MWRROneYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 23) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.MWRRThreeYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 24) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.MWRRFiveYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 25) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.MWRRTenYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 26) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.ActiveReturnOneYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 27) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.ActiveReturnThreeYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 28) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.ActiveReturnFiveYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 29) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.ActiveReturnTenYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 30) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.AlphaOneYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 31) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.AlphaThreeYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 32) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.AlphaFiveYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 33) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.AlphaTenYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 34) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.BetaOneYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 35) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.BetaThreeYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 36) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.BetaFiveYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 37) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.BetaTenYear = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 38) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.CalmarRatio = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 39) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.DownsideDeviation = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 40) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.InformationRatio = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 41) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.KRatio = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 42) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.KellerRatio = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 43) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.SharpeRatio = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 44) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.SortinoRatio = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 45) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.StdDev = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 46) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.TreynorRatio = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 47) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.UlcerIndex = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.PerformanceMeasurement serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.ReportableHolding = function(init) {

		this.Ticker = '';

		this.Shares = 0;

		this.PercentPortfolio = 0;

		this.Value = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.ReportableHolding.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.Ticker) {
			buf[i++] = 0;
			var utf8 = encodeUTF8(this.Ticker);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.Shares) {
			buf[i++] = 1;
			view.setFloat64(i, this.Shares);
			i += 8;
		} else if (Number.isNaN(this.Shares)) {
			buf.set([1, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.PercentPortfolio) {
			if (this.PercentPortfolio > 3.4028234663852886E38 || this.PercentPortfolio < -3.4028234663852886E38)
				throw new Error('colfer: colfer/ReportableHolding field PercentPortfolio exceeds 32-bit range');
			buf[i++] = 2;
			view.setFloat32(i, this.PercentPortfolio);
			i += 4;
		} else if (Number.isNaN(this.PercentPortfolio)) {
			buf.set([2, 0x7f, 0xc0, 0, 0], i);
			i += 5;
		}

		if (this.Value) {
			buf[i++] = 3;
			view.setFloat64(i, this.Value);
			i += 8;
		} else if (Number.isNaN(this.Value)) {
			buf.set([3, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.ReportableHolding serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.ReportableHolding.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var size = readVarint();
			if (size < 0)
				throw new Error('colfer: colfer.ReportableHolding.Ticker size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				throw new Error('colfer: colfer.ReportableHolding.Ticker size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) throw new Error(EOF);
			this.Ticker = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Shares = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			if (i + 4 > data.length) throw new Error(EOF);
			this.PercentPortfolio = view.getFloat32(i);
			i += 4;
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Value = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.ReportableHolding serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Returns = function(init) {

		this.MWRRSinceInception = 0;

		this.MWRRYTD = 0;

		this.MWRROneYear = 0;

		this.MWRRThreeYear = 0;

		this.MWRRFiveYear = 0;

		this.MWRRTenYear = 0;

		this.TWRRSinceInception = 0;

		this.TWRRYTD = 0;

		this.TWRROneYear = 0;

		this.TWRRThreeYear = 0;

		this.TWRRFiveYear = 0;

		this.TWRRTenYear = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.Returns.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.MWRRSinceInception) {
			buf[i++] = 0;
			view.setFloat64(i, this.MWRRSinceInception);
			i += 8;
		} else if (Number.isNaN(this.MWRRSinceInception)) {
			buf.set([0, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.MWRRYTD) {
			buf[i++] = 1;
			view.setFloat64(i, this.MWRRYTD);
			i += 8;
		} else if (Number.isNaN(this.MWRRYTD)) {
			buf.set([1, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.MWRROneYear) {
			buf[i++] = 2;
			view.setFloat64(i, this.MWRROneYear);
			i += 8;
		} else if (Number.isNaN(this.MWRROneYear)) {
			buf.set([2, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.MWRRThreeYear) {
			buf[i++] = 3;
			view.setFloat64(i, this.MWRRThreeYear);
			i += 8;
		} else if (Number.isNaN(this.MWRRThreeYear)) {
			buf.set([3, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.MWRRFiveYear) {
			buf[i++] = 4;
			view.setFloat64(i, this.MWRRFiveYear);
			i += 8;
		} else if (Number.isNaN(this.MWRRFiveYear)) {
			buf.set([4, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.MWRRTenYear) {
			buf[i++] = 5;
			view.setFloat64(i, this.MWRRTenYear);
			i += 8;
		} else if (Number.isNaN(this.MWRRTenYear)) {
			buf.set([5, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TWRRSinceInception) {
			buf[i++] = 6;
			view.setFloat64(i, this.TWRRSinceInception);
			i += 8;
		} else if (Number.isNaN(this.TWRRSinceInception)) {
			buf.set([6, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TWRRYTD) {
			buf[i++] = 7;
			view.setFloat64(i, this.TWRRYTD);
			i += 8;
		} else if (Number.isNaN(this.TWRRYTD)) {
			buf.set([7, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TWRROneYear) {
			buf[i++] = 8;
			view.setFloat64(i, this.TWRROneYear);
			i += 8;
		} else if (Number.isNaN(this.TWRROneYear)) {
			buf.set([8, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TWRRThreeYear) {
			buf[i++] = 9;
			view.setFloat64(i, this.TWRRThreeYear);
			i += 8;
		} else if (Number.isNaN(this.TWRRThreeYear)) {
			buf.set([9, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TWRRFiveYear) {
			buf[i++] = 10;
			view.setFloat64(i, this.TWRRFiveYear);
			i += 8;
		} else if (Number.isNaN(this.TWRRFiveYear)) {
			buf.set([10, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.TWRRTenYear) {
			buf[i++] = 11;
			view.setFloat64(i, this.TWRRTenYear);
			i += 8;
		} else if (Number.isNaN(this.TWRRTenYear)) {
			buf.set([11, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.Returns serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Returns.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.MWRRSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.MWRRYTD = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.MWRROneYear = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.MWRRThreeYear = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 4) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.MWRRFiveYear = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 5) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.MWRRTenYear = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 6) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TWRRSinceInception = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 7) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TWRRYTD = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 8) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TWRROneYear = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 9) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TWRRThreeYear = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 10) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TWRRFiveYear = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 11) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.TWRRTenYear = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.Returns serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.PortfolioHoldingItem = function(init) {

		this.Time = null;
		this.Time_ns = 0;

		this.Holdings = [];

		this.PercentReturn = 0;

		this.Value = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property Holdings will be replaced with a new colfer.ReportableHolding.
	this.PortfolioHoldingItem.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if ((this.Time && this.Time.getTime()) || this.Time_ns) {
			var ms = this.Time ? this.Time.getTime() : 0;
			var s = ms / 1E3;

			var ns = this.Time_ns || 0;
			if (ns < 0 || ns >= 1E6)
				throw new Error('colfer: colfer/PortfolioHoldingItem field Time_ns not in range (0, 1ms>');
			var msf = ms % 1E3;
			if (ms < 0 && msf) {
				s--
				msf = 1E3 + msf;
			}
			ns += msf * 1E6;

			if (s > 0xffffffff || s < 0) {
				buf[i++] = 0 | 128;
				if (s > 0) {
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
				} else {
					s = -s;
					view.setUint32(i, s / 0x100000000);
					view.setUint32(i + 4, s);
					var carry = 1;
					for (var j = i + 7; j >= i; j--) {
						var b = (buf[j] ^ 255) + carry;
						buf[j] = b & 255;
						carry = b >> 8;
					}
				}
				view.setUint32(i + 8, ns);
				i += 12;
			} else {
				buf[i++] = 0;
				view.setUint32(i, s);
				i += 4;
				view.setUint32(i, ns);
				i += 4;
			}
		}

		if (this.Holdings && this.Holdings.length) {
			var a = this.Holdings;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.PortfolioHoldingItem.Holdings length exceeds colferListMax');
			buf[i++] = 1;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.ReportableHolding();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.PercentReturn) {
			buf[i++] = 2;
			view.setFloat64(i, this.PercentReturn);
			i += 8;
		} else if (Number.isNaN(this.PercentReturn)) {
			buf.set([2, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}

		if (this.Value) {
			buf[i++] = 3;
			view.setFloat64(i, this.Value);
			i += 8;
		} else if (Number.isNaN(this.Value)) {
			buf.set([3, 0x7f, 0xf8, 0, 0, 0, 0, 0, 0], i);
			i += 9;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.PortfolioHoldingItem serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.PortfolioHoldingItem.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 8 > data.length) throw new Error(EOF);

			var ms = view.getUint32(i) * 1E3;
			var ns = view.getUint32(i + 4);
			ms += Math.floor(ns / 1E6);
			this.Time = new Date(ms);
			this.Time_ns = ns % 1E6;

			i += 8;
			readHeader();
		} else if (header == (0 | 128)) {
			if (i + 12 > data.length) throw new Error(EOF);

			var ms = decodeInt64(data, i) * 1E3;
			var ns = view.getUint32(i + 8);
			ms += Math.floor(ns / 1E6);
			if (ms < -864E13 || ms > 864E13)
				throw new Error('colfer: colfer/ field Time exceeds ECMA Date range');
			this.Time = new Date(ms);
			this.Time_ns = ns % 1E6;

			i += 12;
			readHeader();
		}

		if (header == 1) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.PortfolioHoldingItem.Holdings length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.PortfolioHoldingItem.Holdings length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.ReportableHolding();
				i += o.unmarshal(data.subarray(i));
				this.Holdings[n] = o;
			}
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.PercentReturn = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) throw new Error(EOF);
			this.Value = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.PortfolioHoldingItem serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.PortfolioHoldingItemList = function(init) {

		this.Items = [];

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property Items will be replaced with a new colfer.PortfolioHoldingItem.
	this.PortfolioHoldingItemList.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.Items && this.Items.length) {
			var a = this.Items;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.PortfolioHoldingItemList.Items length exceeds colferListMax');
			buf[i++] = 0;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.PortfolioHoldingItem();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.PortfolioHoldingItemList serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.PortfolioHoldingItemList.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.PortfolioHoldingItemList.Items length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.PortfolioHoldingItemList.Items length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.PortfolioHoldingItem();
				i += o.unmarshal(data.subarray(i));
				this.Items[n] = o;
			}
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.PortfolioHoldingItemList serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.PortfolioTransactionList = function(init) {

		this.Items = [];

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property Items will be replaced with a new colfer.Transaction.
	this.PortfolioTransactionList.prototype.marshal = function(buf) {
		if (! buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.Items && this.Items.length) {
			var a = this.Items;
			if (a.length > colferListMax)
				throw new Error('colfer: colfer.PortfolioTransactionList.Items length exceeds colferListMax');
			buf[i++] = 0;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function(v, vi) {
				if (v == null) {
					v = new colfer.Transaction();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			throw new Error('colfer: colfer.PortfolioTransactionList serial size ' + i + ' exceeds ' + colferSizeMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.PortfolioTransactionList.prototype.unmarshal = function(data) {
		if (!data || ! data.length) throw new Error(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function() {
			if (i >= data.length) throw new Error(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function() {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i+pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) throw new Error(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var l = readVarint();
			if (l < 0) throw new Error('colfer: colfer.PortfolioTransactionList.Items length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				throw new Error('colfer: colfer.PortfolioTransactionList.Items length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new colfer.Transaction();
				i += o.unmarshal(data.subarray(i));
				this.Items[n] = o;
			}
			readHeader();
		}

		if (header != 127) throw new Error('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			throw new Error('colfer: colfer.PortfolioTransactionList serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// private section

	var encodeVarint = function(bytes, i, x) {
		while (x > 127) {
			bytes[i++] = (x & 127) | 128;
			x /= 128;
		}
		bytes[i++] = x & 127;
		return i;
	}

	function decodeInt64(data, i) {
		var v = 0, j = i + 7, m = 1;
		if (data[i] & 128) {
			// two's complement
			for (var carry = 1; j >= i; --j, m *= 256) {
				var b = (data[j] ^ 255) + carry;
				carry = b >> 8;
				v += (b & 255) * m;
			}
			v = -v;
		} else {
			for (; j >= i; --j, m *= 256)
				v += data[j] * m;
		}
		return v;
	}

	function encodeUTF8(s) {
		var i = 0, bytes = new Uint8Array(s.length * 4);
		for (var ci = 0; ci != s.length; ci++) {
			var c = s.charCodeAt(ci);
			if (c < 128) {
				bytes[i++] = c;
				continue;
			}
			if (c < 2048) {
				bytes[i++] = c >> 6 | 192;
			} else {
				if (c > 0xd7ff && c < 0xdc00) {
					if (++ci >= s.length) {
						bytes[i++] = 63;
						continue;
					}
					var c2 = s.charCodeAt(ci);
					if (c2 < 0xdc00 || c2 > 0xdfff) {
						bytes[i++] = 63;
						--ci;
						continue;
					}
					c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
					bytes[i++] = c >> 18 | 240;
					bytes[i++] = c >> 12 & 63 | 128;
				} else bytes[i++] = c >> 12 | 224;
				bytes[i++] = c >> 6 & 63 | 128;
			}
			bytes[i++] = c & 63 | 128;
		}
		return bytes.subarray(0, i);
	}

	function decodeUTF8(bytes) {
		var i = 0, s = '';
		while (i < bytes.length) {
			var c = bytes[i++];
			if (c > 127) {
				if (c > 191 && c < 224) {
					c = (i >= bytes.length) ? 63 : (c & 31) << 6 | bytes[i++] & 63;
				} else if (c > 223 && c < 240) {
					c = (i + 1 >= bytes.length) ? 63 : (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
				} else if (c > 239 && c < 248) {
					c = (i + 2 >= bytes.length) ? 63 : (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
				} else c = 63
			}

			if (c <= 0xffff) s += String.fromCharCode(c);
			else if (c > 0x10ffff) s += '?';
			else {
				c -= 0x10000;
				s += String.fromCharCode(c >> 10 | 0xd800)
				s += String.fromCharCode(c & 0x3FF | 0xdc00)
			}
		}
		return s;
	}
}

// NodeJS:
if (typeof exports !== 'undefined') exports.colfer = colfer;
